# -*- coding: utf-8 -*-
"""ALESS code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xvcrqBdhEBxqhkx3wEj9NfHQtJvQGyGS
"""



# ===========================================================
# 2D Reaction–Diffusion Lotka–Volterra System
# Resource distributions normalized so that total resource is equal
# Patterns: uniform, center, edge, corners, corner
# ===========================================================

import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter

# ------------------------
# Simulation parameters
# ------------------------
nx = 80
dx = 1.0
dt = 0.05
nt = 1000
record_interval = 10

# Biological parameters
b = 0.5
c = 0.3
d = 0.25
Du = 0.5
Dv = 0.05

resource_scale = 5.0
patch_size = 12

# ------------------------
# Helper functions
# ------------------------
def laplacian(Z, dx):
    Zp = np.pad(Z, 1, mode='edge')
    lap = (Zp[2:,1:-1] + Zp[:-2,1:-1] + Zp[1:-1,2:] + Zp[1:-1,:-2] - 4*Z) / (dx*dx)
    return lap


def make_resource_map(kind='uniform', nx=80, scale=5.0, patch_size=10):
    """Generate smooth Gaussian-like resource distributions, then normalize."""
    m = np.ones((nx, nx))
    X, Y = np.indices((nx, nx))
    cx, cy = nx//2, nx//2

    if kind == 'uniform':
        m = np.ones((nx, nx))

    elif kind == 'center':
        sigma = nx / 5.0
        m += scale * np.exp(-((X - cx)**2 + (Y - cy)**2) / (2 * sigma**2))

    elif kind == 'edge':
        dist = np.sqrt((X - cx)**2 + (Y - cy)**2)
        m += scale * np.exp(-((dist - dist.max())**2) / (2 * (nx/6.0)**2))

    elif kind == 'corners':
        sigma = patch_size
        centers = [
            (patch_size, patch_size),
            (nx - patch_size, patch_size),
            (patch_size, nx - patch_size),
            (nx - patch_size, nx - patch_size)
        ]
        for (cx0, cy0) in centers:
            m += scale * np.exp(-((X - cx0)**2 + (Y - cy0)**2) / (2 * sigma**2))

    elif kind == 'corner':
        sigma = patch_size
        centers = [
            (patch_size, patch_size),
        ]
        for (cx0, cy0) in centers:
            m += scale * np.exp(-((X - cx0)**2 + (Y - cy0)**2) / (2 * sigma**2))

    # Smooth the map
    m = gaussian_filter(m, sigma=2)

    # ------------------------
    # Normalize resource total
    # ------------------------
    target_total = nx * nx  # same as uniform distribution
    m = m / m.sum() * target_total

    return m


def simulate(resource_kind):
    m = make_resource_map(kind=resource_kind, nx=nx, scale=resource_scale, patch_size=patch_size)

    np.random.seed(0)
    u = 0.5 + 0.01 * np.random.rand(nx, nx)  # prey
    v = 0.2 + 0.01 * np.random.rand(nx, nx)  # predator

    total_u, total_v, times = [], [], []

    for step in range(nt + 1):
        if step % record_interval == 0:
            total_u.append(u.sum())
            total_v.append(v.sum())
            times.append(step * dt)

        Lu = laplacian(u, dx)
        Lv = laplacian(v, dx)

        ru = u * (m - u - b * v)
        rv = v * (-c + d * u)

        u += dt * (Du * Lu + ru)
        v += dt * (Dv * Lv + rv)

        u[u < 0] = 0
        v[v < 0] = 0

    return m, u, v, times, total_u, total_v


# ------------------------
# Run all simulations
# ------------------------
patterns = ['uniform', 'center', 'edge', 'corners','corner']
results = {}

print("Running normalized resource simulations:")
for kind in patterns:
    print(f"  {kind}")
    m, u, v, times, total_u, total_v = simulate(kind)
    results[kind] = (m, u, v, times, total_u, total_v)

import matplotlib.gridspec as gridspec

#  Initial resource maps
fig = plt.figure(figsize=(12, 3))

# Number of columns = number of patterns + one column for the color bar
ncols = len(patterns) + 1
width_ratios = [1] * len(patterns) + [0.05]

gs = gridspec.GridSpec(1, ncols, width_ratios=width_ratios)

axes = []
for i, kind in enumerate(patterns):
    ax = fig.add_subplot(gs[i])
    axes.append(ax)
    m, _, _, _, _, _ = results[kind]
    im = ax.imshow(m, origin='lower', cmap='viridis')
    ax.set_title(f"Resource: {kind}")
    ax.axis('off')

# Dedicated axis for the color bar
cax = fig.add_subplot(gs[-1])
fig.colorbar(im, cax=cax)

fig.suptitle("Initial Normalized Resource Distributions", fontsize=14)
plt.tight_layout()
plt.show()


# ------------------------
# Population time series
# ------------------------
plt.figure(figsize=(9, 5))
for kind in patterns:
    _, _, _, times, total_u, total_v = results[kind]
    plt.plot(times, np.array(total_u) + np.array(total_v), label=f"{kind}")

plt.xlabel("Time")
plt.ylabel("Total population (prey + predator)")
plt.title("Population over time (normalized resource)")
plt.legend()
plt.tight_layout()
plt.show()

# ------------------------
# Final population maps
# ------------------------
for kind in patterns:
    m, u, v, _, _, _ = results[kind]

    fig, axs = plt.subplots(1, 2, figsize=(8, 3))
    im1 = axs[0].imshow(u, origin='lower', cmap='plasma')
    axs[0].set_title(f"Prey (final) - {kind}")
    axs[0].axis('off')

    im2 = axs[1].imshow(v, origin='lower', cmap='inferno')
    axs[1].set_title(f"Predator (final) - {kind}")
    axs[1].axis('off')

    plt.colorbar(im1, ax=axs[0], fraction=0.046, pad=0.04)
    plt.colorbar(im2, ax=axs[1], fraction=0.046, pad=0.04)

    plt.suptitle(f"Final Population (Normalized Resource) - {kind}", fontsize=13)
    plt.tight_layout()
    plt.show()

print(" Normalized resource simulations completed.")